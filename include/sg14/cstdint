
//          Copyright John McFarlane 2015 - 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

/// \file
/// \brief additions to <cstdint> proposed in P0381

#if !defined(SG14_CSTDINT_H)
#define SG14_CSTDINT_H 1

#if ! defined(SG14_GODBOLT_ORG)
#include "bits/config.h"
#endif

#include <climits>
#include <cstdint>
#include <tuple>
#include <type_traits>

/// study group 14 of the C++ working group
namespace sg14 {
    using _width_type = unsigned;

    ////////////////////////////////////////////////////////////////////////////////
    // width - new type property which returns number of bits of information

    /// \brief provides width of numeric type
    ///
    /// \tparam Type given numeric type
    ///
    /// \remarks If \c Type is a fixed-point numeric type such as an integral type,
    /// \c width<Type>::value is the width of Type in bits.
    /// \remarks The width is defined as the number of digits including any sign bit.
    /// \remarks The template may be specialized for custom types.

    template<class Type>
    struct width;

    template<>
    struct width<char> : std::integral_constant<_width_type, sizeof(char)*CHAR_BIT> {
    };
    template<>
    struct width<wchar_t> : std::integral_constant<_width_type, sizeof(wchar_t)*CHAR_BIT> {
    };

    template<>
    struct width<signed char> : std::integral_constant<_width_type, sizeof(signed char)*CHAR_BIT> {
    };
    template<>
    struct width<unsigned char> : std::integral_constant<_width_type, sizeof(unsigned char)*CHAR_BIT> {
    };

    template<>
    struct width<signed short> : std::integral_constant<_width_type, sizeof(signed short)*CHAR_BIT> {
    };
    template<>
    struct width<unsigned short> : std::integral_constant<_width_type, sizeof(unsigned short)*CHAR_BIT> {
    };

    template<>
    struct width<signed int> : std::integral_constant<_width_type, sizeof(signed int)*CHAR_BIT> {
    };
    template<>
    struct width<unsigned int> : std::integral_constant<_width_type, sizeof(unsigned int)*CHAR_BIT> {
    };

    template<>
    struct width<signed long> : std::integral_constant<_width_type, sizeof(signed long)*CHAR_BIT> {
    };
    template<>
    struct width<unsigned long> : std::integral_constant<_width_type, sizeof(unsigned long)*CHAR_BIT> {
    };

    template<>
    struct width<signed long long> : std::integral_constant<_width_type, sizeof(signed long long)*CHAR_BIT> {
    };
    template<>
    struct width<unsigned long long> : std::integral_constant<_width_type, sizeof(unsigned long long)*CHAR_BIT> {
    };

    template<>
    struct width<float> : std::integral_constant<_width_type, sizeof(float)*CHAR_BIT> {
    };
    template<>
    struct width<double> : std::integral_constant<_width_type, sizeof(double)*CHAR_BIT> {
    };
    template<>
    struct width<long double> : std::integral_constant<_width_type, sizeof(long double)*CHAR_BIT> {
    };

	template<class Type>
    struct width : width<typename std::remove_cv<Type>::type> {};

#if defined(SG14_INT128_ENABLED)
    // sg14::width
    template<>
    struct width<SG14_INT128> : std::integral_constant<_width_type, sizeof(SG14_INT128)*CHAR_BIT> {
    };

    template<>
    struct width<SG14_UINT128> : std::integral_constant<_width_type, sizeof(SG14_UINT128)*CHAR_BIT> {
    };
#endif

#if (__cplusplus>=201402L)
    ////////////////////////////////////////////////////////////////////////////////
    // width_v - equals number of bits of information in given type

    /// \brief provides width of numeric type
    ///
    /// \tparam Type given numeric type
    ///
    /// \remarks The width is defined as the number of digits including any sign bit.

    template<class Type>
    constexpr unsigned width_v = width<Type>::value;
#endif

    namespace _set_width_impl {
        ////////////////////////////////////////////////////////////////////////////////
        // sg14::_set_width_impl::enable_for_range

        template<_width_type MinNumBits, class Smaller, class T>
        struct enable_for_range
                : std::enable_if<MinNumBits<=CHAR_BIT*sizeof(T)&&CHAR_BIT*sizeof(Smaller)<MinNumBits> {};

        template<_width_type MinNumBits, class Smallest>
        struct enable_for_range<MinNumBits, void, Smallest>
                : std::enable_if<MinNumBits<=CHAR_BIT*sizeof(Smallest)> {};

        template<_width_type MinNumBits, class Smaller, class T>
        using enable_for_range_t = typename enable_for_range<MinNumBits, Smaller, T>::type;

        ////////////////////////////////////////////////////////////////////////////////
        // sg14::_set_width_impl::set_width_signed

        template<_width_type MinNumBits, class Enable = void>
        struct set_width_signed;

        template<_width_type MinNumBits>
        struct set_width_signed<MinNumBits, enable_for_range_t<MinNumBits, void, std::int8_t>> {
            using type = std::int8_t;
        };

        template<_width_type MinNumBits>
        struct set_width_signed<MinNumBits, enable_for_range_t<MinNumBits, std::int8_t, std::int16_t>> {
            using type = std::int16_t;
        };

        template<_width_type MinNumBits>
        struct set_width_signed<MinNumBits, enable_for_range_t<MinNumBits, std::int16_t, std::int32_t>> {
            using type = std::int32_t;
        };

        template<_width_type MinNumBits>
        struct set_width_signed<MinNumBits, enable_for_range_t<MinNumBits, std::int32_t, std::int64_t>> {
            using type = std::int64_t;
        };

#if defined(SG14_INT128_ENABLED)
        template<_width_type MinNumBits>
        struct set_width_signed<MinNumBits, enable_for_range_t<MinNumBits, std::int64_t, SG14_INT128>> {
            using type = SG14_INT128;
        };
#endif

        ////////////////////////////////////////////////////////////////////////////////
        // sg14::_set_width_impl::set_width_unsigned

        template<_width_type MinNumBits, class Enable = void>
        struct set_width_unsigned;

        template<_width_type MinNumBits>
        struct set_width_unsigned<MinNumBits, enable_for_range_t<MinNumBits, void, std::uint8_t>> {
            using type = std::uint8_t;
        };

        template<_width_type MinNumBits>
        struct set_width_unsigned<MinNumBits, enable_for_range_t<MinNumBits, std::uint8_t, std::uint16_t>> {
            using type = std::uint16_t;
        };

        template<_width_type MinNumBits>
        struct set_width_unsigned<MinNumBits, enable_for_range_t<MinNumBits, std::uint16_t, std::uint32_t>> {
            using type = std::uint32_t;
        };

        template<_width_type MinNumBits>
        struct set_width_unsigned<MinNumBits, enable_for_range_t<MinNumBits, std::uint32_t, std::uint64_t>> {
            using type = std::uint64_t;
        };

#if defined(SG14_INT128_ENABLED)
        template<_width_type MinNumBits>
        struct set_width_unsigned<MinNumBits, enable_for_range_t<MinNumBits, std::uint64_t, SG14_UINT128>> {
            using type = SG14_UINT128;
        };
#endif

        ////////////////////////////////////////////////////////////////////////////////
        // sg14::_set_width_impl::set_width_float

        template<_width_type MinNumBits, class Enable = void>
        struct set_width_float;

        template<_width_type MinNumBits>
        struct set_width_float<MinNumBits, enable_for_range_t<MinNumBits, void, float>> {
            using type = float;
        };

        template<_width_type MinNumBits>
        struct set_width_float<MinNumBits, enable_for_range_t<MinNumBits, float, double>> {
            using type = double;
        };

        template<_width_type MinNumBits>
        struct set_width_float<MinNumBits, enable_for_range_t<MinNumBits, double, long double>> {
            using type = long double;
        };
    }

    /// resizes a type;
    /// can be specialized for any type for which resizing that type makes sense
    ///
    /// \sa set_width_t
    template<class Type, _width_type MinNumBits>
    struct set_width;

    // signed/unsigned -> type of correct width
    template<>
    struct set_width<char, sizeof(char) * CHAR_BIT> {
        using type = char;
    };
    template<>
    struct set_width<wchar_t, sizeof(wchar_t) * CHAR_BIT> {
        using type = wchar_t;
    };

    // sg14::set_width specialized for char/wchar_t
    template<_width_type MinNumBits>
    struct set_width<char, MinNumBits>
            : std::conditional<std::is_signed<char>::value,
                    _set_width_impl::set_width_signed<MinNumBits>,
                    _set_width_impl::set_width_unsigned<MinNumBits>>::type {
    };
    template<_width_type MinNumBits>
    struct set_width<wchar_t, MinNumBits>
            : std::conditional<std::is_signed<wchar_t>::value,
                    _set_width_impl::set_width_signed<MinNumBits>,
                    _set_width_impl::set_width_unsigned<MinNumBits>> {
    };

    // sg14::set_width specialized for 8-bit built-in integers
    template<_width_type MinNumBits>
    struct set_width<signed char, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<unsigned char, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };

    // sg14::set_width specialized for 16-bit built-in integers
    template<_width_type MinNumBits>
    struct set_width<signed short, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<unsigned short, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };

    // sg14::set_width specialized for 32-bit built-in integers
    template<_width_type MinNumBits>
    struct set_width<signed int, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<unsigned int, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };

    // sg14::set_width specialized for 64-bit built-in integers
    template<_width_type MinNumBits>
    struct set_width<signed long, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<unsigned long, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };

    // sg14::set_width specialized for 64-bit built-in integers
    template<_width_type MinNumBits>
    struct set_width<signed long long, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<unsigned long long, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };

    // sg14::set_width specialized for 128-bit built-in integers on Clang/GCC
#if defined(SG14_INT128_ENABLED)
    template<_width_type MinNumBits>
    struct set_width<SG14_INT128, MinNumBits>
            : _set_width_impl::set_width_signed<MinNumBits> {
    };
    template<_width_type MinNumBits>
    struct set_width<SG14_UINT128, MinNumBits>
            : _set_width_impl::set_width_unsigned<MinNumBits> {
    };
#endif

    // sg14::set_width specialized for float
    template<_width_type MinNumBits>
    struct set_width<float, MinNumBits>
            : _set_width_impl::set_width_float<MinNumBits> {
    };

    // sg14::set_width specialized for double
    template<_width_type MinNumBits>
    struct set_width<double, MinNumBits>
            : _set_width_impl::set_width_float<MinNumBits> {
    };

    // sg14::set_width specialized for long double
    template<_width_type MinNumBits>
    struct set_width<long double, MinNumBits>
        : _set_width_impl::set_width_float<MinNumBits> {
    };

    /// \brief resizes a type
    ///
    /// \tparam Type the type to resize
    /// \tparam MinNumBits the desired width in bits
    ///
    /// \par Examples
    ///
    /// To resize a native-sized unsigned int to 2-bytes:
    /// \snippet snippets.cpp use set_width 1
    ///
    /// To resize a signed byte type to a built-in signed type of at least 5 bytes:
    /// \snippet snippets.cpp use set_width 2
    ///
    /// To resize a signed, 1-byte fixed-point type to a fixed-point type of at least 3 bytes:
    /// \snippet snippets.cpp use set_width 3
    template<class Type, _width_type MinNumBits>
    using set_width_t = typename set_width<Type, MinNumBits>::type;

    ////////////////////////////////////////////////////////////////////////////////
    // sg14::scale<>

    template<class Integer>
    struct scale;

    template<class Integer>
    struct scale {
        using result_type = decltype(std::declval<Integer>()*std::declval<Integer>());

        static constexpr result_type pown(int base, int exp) {
            return exp
                   ? pown(base, exp - 1) * static_cast<result_type>(base)
                   : static_cast<result_type>(1);
        }

        static constexpr result_type pow2(int exp) {
            return result_type{1} << exp;
        }

        static constexpr result_type pow(int base, int exp)
        {
            return (base==2) ? pow2(exp) : pown(base, exp);
        }

        constexpr result_type operator()(const Integer& i, int base, int exp) const {
            return (exp < 0) ? i / pow(base, -exp) : i * pow(base, exp);
        }
    };
}

#endif	// SG14_CSTDINT_H
